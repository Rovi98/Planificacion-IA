\title{}
\date{\today}
\documentclass[12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{appendix}
\usepackage[hidelinks]{hyperref}

\author{Carlos Bergillos, Adrià Cabeza, Roger Vilaseca}

\setcounter{tocdepth}{3}

\begin{document}

\maketitle

\newpage

\tableofcontents

\newpage


\section{Introducción}

\section{Descripción del problema}
En esta práctica nos encargaremos de planificar un proyecto de programación de gran envergadura.
Deberemos repartir un conjunto de tareas a realizar entre los programadores disponibles.

En concreto, disponemos de $T$ tareas de programación, cada una de ellas tiene un grado de dificultad asignado (de 1 a 3), y un tiempo estimado de realización estimado (en horas).

También disponemos de un conjunto $P$ de programadores. Cada uno de ellos tiene asignado un grado de habilidad (de 1 a 3), que nos indica lo mucho o poco que éste está capacitado para resolver las tareas.

No queremos asignar a los programadores tareas mucho más difíciles de lo que para ellos están capacitados. En concreto, a un programador solo le podremos asignar tareas de como mucho una unidad más de dificultad de lo que nos indique su habilidad. En caso de que sea necesario asignar a un programador una tarea más difícil que su capacidad, la duración de la realización de la tarea se verá incrementada en 2 horas.

Además, todas las tareas deberán ser revisadas, para ello, hará falta una nueva tarea adicional. Esta nueva tarea de revisión será de la misma dificultad que la tarea original.
Los programadores tienen también asociada una calidad (de 1 a 2). Si la tarea original es realizada por un programador de calidad 1, la nueva tarea de revisión durará 1 hora, si en cambio el programador era de calidad 2, la nueva tarea de revisión durará 2 horas. 
Para evitar una recursividad infinita, las nuevas tareas de revisión no requerirán a su vez de revisión, y su tiempo de realización no se verá penalizado por la habilidad del programador que la realiza.


\section{Nivel básico} \label{basic}
En esta primera versión problema, solamente tendremos como objetivo que todas las tareas queden asignadas a algún programador, sin tener en cuenta las tareas de revisión asociadas, y sin intentar optimizar ningún criterio.

\subsection{Dominio}
\subsubsection{Variables}
Para la correcta resolución de este problema de planificación hemos visto conveniente trabajar con variables con tipo.
En concreto, hemos necesitado 2 tipos, los cuáles hemos llamado \textbf{programador} y \textbf{tarea}.

\begin{itemize}
  \item \textbf{programador:} Se utilizará para las variables que correspondan a cada programador del conjunto $P$.
  \item \textbf{tarea:} Se utilizará para las variables que correspondan a cada tarea del conjunto $T$.
\end{itemize}

Para las próximas extensiones ya no se requieren más cambios en las variables, esta será la configuración definitiva.

\subsubsection{Funciones}
\begin{itemize}
  \item \textbf{habilidadProgramador:} Esta función nos servirá para definir y conocer la habilidad de un programador determinado. La habilidad de un programador se representa con un número entero 1, 2 o 3.
  \item \textbf{dificultadTarea:} Esta función nos servirá para definir y conocer la dificultad de una tarea determinada. La dificultad de una tarea se representa con un número entero 1, 2 o 3.
\end{itemize}
\subsubsection{Predicados} \label{basic_predicado}
\begin{itemize}
  \item \verb|(asignacion ?x - programador ?y - tarea)|
  
  Al programador \texttt{x} se le ha sido asignada la tarea \texttt{y}, por lo tanto, éste deberá ser el encargado de realizarla.
  
  \item \verb|(tareaAsignada ?x - tarea)|
  
  Nos indica que la tarea \texttt{x} ha sido asignada a algún programador. Nos servirá para evitar asignar dos veces la misma tarea.
\end{itemize}
\subsubsection{Acciones} \label{basic_accion}
\begin{itemize}
  \item \textbf{asignar:} Esta acción nos sirve para asignar una tarea a un programador.
  
  \textbf{Parámetros}
  \begin{itemize}
  	\item \verb|?p - programador|
  	\item \verb|?t - tarea|
  \end{itemize}
  
  \textbf{Precondición}
  \begin{itemize}
  	\item La tarea \texttt{t} no está asignada.
  	\item La habilidad del programador \texttt{p} debe ser más grande o igual que la dificultad de la tarea \texttt{p} más uno.
  \end{itemize}
  
   \textbf{Postcondición}
   \begin{itemize}
  	\item La tarea \texttt{t} ha sido asignada al programador \texttt{p}.
  \end{itemize}
  
\end{itemize}

\subsection{Problema}
\subsubsection{Objetos}
Para la modelización del problema tenemos que definir las tareas y programadores de los que disponemos, declarando tantas variables (objetos) como requiramos.

\subsubsection{Estado inicial} \label{basic_estadoinicial}
En el estado inicial, para cada tarea y programador de los que disponemos, especificaremos su información asociada, como la habilidad de cada programador, o la dificultad de las tareas.

\subsubsection{Estado final}
Para el estado final, requerimos que todas las tareas estén asignadas:

\begin{verbatim}
(:goal (forall (?t - tarea) (tareaAsignada ?t))))
\end{verbatim}

\subsection{Juegos de prueba}


\section{Extensión 1}

En esta extensión, vamos a añadir a nuestro programa la revisión de tareas.
La revisión de tareas consiste en que cada vez que algún programador realice una tarea, esta deberá ser revisada por otro programador. La dificultad de la revisión será la misma que de la tarea y por lo tanto utilizaremos el mismo criterio para asignar un programador, para revisar que en la sección \ref{basic}.

\subsection{Dominio}
\subsubsection{Funciones}

Para esta extensión vamos a utilizar las mismas funciones que en el apartado anterior.

\subsubsection{Predicados}

\begin{itemize}
  \item \textbf{asignacionTarea:} Equivalente al predicado "asignacion" en la sección \ref{basic_predicado}.
  \item \textbf{asignacionRevision:} Predicado utilizado para asignar a una tarea un programador para que este la revise. 
  \item \textbf{tareaAsignada:} Igual que en la sección \ref{basic_predicado}.
  \item \textbf{tareaRevisada:} Predicado para conocer si la tarea en questión ha sido revisada por algún programador.
\end{itemize}

\subsubsection{Acciones}

\begin{itemize}
  \item \textbf{asignar:} Esta acción és equivalente a la acción ``asignar" explicada en la sección \ref{basic_accion}. Donde el único cambio es el cambio de nombre del predicado de ``asignacion" a "asignacionTarea".
  \item \textbf{revisar:} El objetivo de esta acción es a partir de las tareas ya asignadas, asignar una revisión a todas la tareas con un programador diferente del que ha tenido asignada la tarea, el cual debe tener habilidad suficientemente grande para poder revisarla.
  
  \textbf{Parámetros}
  \begin{itemize}
  	\item \verb|?p - programador|
  	\item \verb|?t - tarea|
  \end{itemize}
  
  \textbf{Precondición}
  
  Para poder realizar esta acción se debe cumplir:
  \begin{itemize}
  	\item La tarea debe estar asignada.
  	\item La tarea no debe estar revisada
  	\item La habilidad del programador debe ser más grande o igual que la dificultad de la tarea más uno.
  	\item El programador que revisa la tarea no puede ser el mismo que el que le ha sido asignada.
  \end{itemize}
  
  (and (tareaAsignada ?t) (not (tareaRevisada ?t)) (>= (habilidadProgramador ?p) (- (dificultadTarea ?t) 1)) (not (asignacionTarea ?p ?t)))
  
  \textbf{Postcondición}
  
  \begin{itemize}
  	\item Un programador será el revisor de la tarea.
  	\item La tarea estará revisada.
  \end{itemize}
  
  (and (asignacionRevision ?p ?t) (tareaRevisada ?t))
  
\end{itemize}

\subsection{Problema}
\subsubsection{Estado inicial}

En este caso el estado inicial será equivalente al de la sección \ref{basic_estadoinicial}.

\subsubsection{Estado final}

El estado final remplazaremos la comprobación de de que todas las tareas estén asignadas, por la comprobación de que todas las tareas estén revisadas.

(forall (?t - tarea) (tareaRevisada ?t))

\subsection{Juegos de prueba}



\section{Extensión 2}

\subsection{Dominio}
\subsubsection{Funciones}
\subsubsection{Predicados}
\subsubsection{Acciones}

\subsection{Problema}
\subsubsection{Estado inicial}
\subsubsection{Estado final}

\subsection{Juegos de prueba}


\section{Extensión 3}

\subsection{Dominio}
\subsubsection{Funciones}
\subsubsection{Predicados}
\subsubsection{Acciones}

\subsection{Problema}
\subsubsection{Estado inicial}
\subsubsection{Estado final}

\subsection{Juegos de prueba}


\section{Extensión 4}

\subsection{Dominio}
\subsubsection{Funciones}
\subsubsection{Predicados}
\subsubsection{Acciones}

\subsection{Problema}
\subsubsection{Estado inicial}
\subsubsection{Estado final}

\subsection{Juegos de prueba}


\section{Conclusiones}


\newpage
\appendix
\appendixpage
\addappheadtotoc

\section{Generador de juegos de prueba}


\end{document}