\title{}
\date{\today}
\documentclass[12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{appendix}
\usepackage[hidelinks]{hyperref}

\author{Carlos Bergillos, Adrià Cabeza, Roger Vilaseca}

\setcounter{tocdepth}{3}

\begin{document}

\maketitle

\newpage

\tableofcontents

\newpage


\section{Introducción}

\section{Descripción del problema}
En esta práctica nos encargaremos de planificar un proyecto de programación de gran envergadura.
Deberemos repartir un conjunto de tareas a realizar entre los programadores disponibles.

En concreto, disponemos de $T$ tareas de programación, cada una de ellas tiene un grado de dificultad asignado (de 1 a 3), y un tiempo estimado de realización estimado (en horas).

También disponemos de un conjunto $P$ de programadores. Cada uno de ellos tiene asignado un grado de habilidad (de 1 a 3), que nos indica lo mucho o poco que éste está capacitado para resolver las tareas.

No queremos asignar a los programadores tareas mucho más difíciles de lo que para ellos están capacitados. En concreto, a un programador solo le podremos asignar tareas de como mucho una unidad más de dificultad de lo que nos indique su habilidad. En caso de que sea necesario asignar a un programador una tarea más difícil que su capacidad, la duración de la realización de la tarea se verá incrementada en 2 horas.

Además, todas las tareas deberán ser revisadas, para ello, hará falta una nueva tarea adicional. Esta nueva tarea de revisión será de la misma dificultad que la tarea original.
Los programadores tienen también asociada una calidad (de 1 a 2). Si la tarea original es realizada por un programador de calidad 1, la nueva tarea de revisión durará 1 hora, si en cambio el programador era de calidad 2, la nueva tarea de revisión durará 2 horas. 
Para evitar una recursividad infinita, las nuevas tareas de revisión no requerirán a su vez de revisión, y su tiempo de realización no se verá penalizado por la habilidad del programador que la realiza.


\section{Nivel básico} \label{basic}
En esta primera versión....


\subsection{Dominio}
\subsubsection{Variables}
Para la correcta resolución de este problema de planificación hemos visto conveniente trabajar con variables con tipo.
En concreto, hemos necesitado 2 tipos, los cuáles hemos llamado \textbf{programador} y \textbf{tarea}.

\begin{itemize}
  \item \textbf{programador:} Se utilizará para las variables que correspondan a cada programador del conjunto $P$.
  \item \textbf{tarea:} Se utilizará para las variables que correspondan a cada tarea del conjunto $T$.
\end{itemize}

Para las próximas extensiones ya no se requieren más cambios en las variables, esta será la configuración definitiva.

\subsubsection{Funciones}
\begin{itemize}
  \item \textbf{habilidadProgramador:} Esta función nos servirá para definir y conocer la habilidad de un programador determinado. La habilidad de un programador se representa con un número entero 1, 2 o 3.
  \item \textbf{dificultadTarea:} Esta función nos servirá para definir y conocer la dificultad de una tarea determinada. La dificultad de una tarea se representa con un número entero 1, 2 o 3.
\end{itemize}
\subsubsection{Predicados} \label{basic_predicado}
\begin{itemize}
  \item \textbf{asignacion:}
  \item \textbf{tareaAsignada:}
\end{itemize}
\subsubsection{Acciones} \label{basic_accion}
\begin{itemize}
  \item \textbf{asignar:}
\end{itemize}

\subsection{Problema}
\subsubsection{Objetos}
\subsubsection{Estado inicial} \label{basic_estadoinicial}
\subsubsection{Estado final}

\subsection{Juegos de prueba}


\section{Extensión 1}

En esta extensión, vamos a añadir a nuestro programa la revision de tareas.
La revisón de tareas consiste en que cada vez que algun programador realice una tarea, esta deberá ser revisada por otro programador. La dificultad de la revision será la misma que de la tarea y por lo tanto utilizaremos el mismo criterio para asignar un programador, para revisar que en la sección \ref{basic}.

\subsection{Dominio}
\subsubsection{Funciones}

Para esta extensión vamos a utilizar las mismas funciones que en el apartado anterior.

\subsubsection{Predicados}

\begin{itemize}
  \item \textbf{asignacionTarea:} Equivalente al predicado "asignacion" en la seccion \ref{basic_predicado}.
  \item \textbf{asignacionRevision:} Predicado utilizado para asignar a una tarea un programador para que este la revise. 
  \item \textbf{tareaAsignada:} Igual que en la sección \ref{basic_predicado}.
  \item \textbf{tareaRevisada:} Predicado para conocer si la tarea en questión ha sido revisada por algún programador.
\end{itemize}

\subsubsection{Acciones}

\begin{itemize}
  \item \textbf{asignar:} Esta acción és equivalente a la acción "assignar" explicada en la sección \ref{basic_accion}. Donde el único cambio és el cambio de nombre del predicado de "asignacion" a "asignacionTarea".
  \item \textbf{revisar:} El objetivo de esta acción es a partir de las tareas ya asignadas, asignar una revisión a todas la tareas con un programador diferente del que ha tenido asignada la tarea, el cual debe tener habilidad suficientemente grande para poder revisarla.
  
  \textbf{Parametros}
  \begin{itemize}
  	\item ?p - programador
  	\item ?t - tarea
  \end{itemize}
  
  \textbf{Precondición}
  
  Para poder realizar esta acción se debe cumplir:
  \begin{itemize}
  	\item La tarea debe estar asignada.
  	\item La tarea no debe estar revisada
  	\item La habilidad del programador debe ser màs grande o igual que la dificultad de la tarea más uno.
  	\item El programador que revisa la tarea no puede ser el mismo que el que le ha sido asignada.
  \end{itemize}
  
  (and (tareaAsignada ?t) (not (tareaRevisada ?t)) (>= (habilidadProgramador ?p) (- (dificultadTarea ?t) 1)) (not (asignacionTarea ?p ?t)))
  
  \textbf{Postcondición}
  
  Esta acción probocará:
  \begin{itemize}
  	\item Un programador será el revisor de la tarea.
  	\item La tarea estará revisada.
  \end{itemize}
  
  (and (asignacionRevision ?p ?t) (tareaRevisada ?t))
  
\end{itemize}

\subsection{Problema}
\subsubsection{Estado inicial}

En este caso el estado inicial serà equivalente al de la sección \ref{basic_estadoinicial}.

\subsubsection{Estado final}

El estado final remplazaremos la comprovación de de que todas las tareas estén asignadas, por la comprovación de que todas las tareas estén revisadas.

(forall (?t - tarea) (tareaRevisada ?t))

\subsection{Juegos de prueba}



\section{Extensión 2}

\subsection{Dominio}
\subsubsection{Funciones}
\subsubsection{Predicados}
\subsubsection{Acciones}

\subsection{Problema}
\subsubsection{Estado inicial}
\subsubsection{Estado final}

\subsection{Juegos de prueba}


\section{Extensión 3}

\subsection{Dominio}
\subsubsection{Funciones}
\subsubsection{Predicados}
\subsubsection{Acciones}

\subsection{Problema}
\subsubsection{Estado inicial}
\subsubsection{Estado final}

\subsection{Juegos de prueba}


\section{Extensión 4}

\subsection{Dominio}
\subsubsection{Funciones}
\subsubsection{Predicados}
\subsubsection{Acciones}

\subsection{Problema}
\subsubsection{Estado inicial}
\subsubsection{Estado final}

\subsection{Juegos de prueba}


\section{Conclusiones}


\newpage
\appendix
\appendixpage
\addappheadtotoc

\section{Generador de juegos de prueba}


\end{document}