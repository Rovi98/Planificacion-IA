\title{}
\date{\today}
\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{appendix}
\date{Junio 3, 2019}
\usepackage[margin=1.4in]{geometry}
\usepackage[hidelinks]{hyperref}
\renewcommand{\appendixname}{Anexo}
\renewcommand{\contentsname}{Índice}
\renewcommand{\appendixpagename}{Anexos}
\author{Carlos Bergillos, Adrià Cabeza, Roger Vilaseca}
\title{Asignación de tareas a programadores usando PDDL  \\ \large IA FIB @ UPC}
\setcounter{tocdepth}{3}

\begin{document}

\maketitle
\vspace*{\fill}
\begin{center}
\includegraphics[scale=0.35]{images/UPClogo.png}
\end{center}
\newpage

\tableofcontents

\newpage


\section{Introducción}
En esta práctica tendremos que resolver un problema de planificación usando \emph{Metric FastForward} (\emph{Metric-FF}). Éste es un planificador que nos permite resolver problemas de planificación definidos en lenguaje PDDL (\emph{Planning Domain Definition Language}).

La modelización de los problemas PDDL se divide conceptualmente en dos partes:
\begin{itemize}
	\item \textbf{Modelización del dominio:} Contiene las definiciones del ``mundo" del problema. Definiremos aquí todo aquello que es invariante para cualquier instanciación del problema, por ejemplo los tipos, las acciones y los predicados disponibles.
	\item \textbf{Modelización del problema:} Contiene la información concreta del problema para el dominio dado. Pueden existir infinitos problemas para un mismo dominio. Por ejemplo, aquí definiremos los objetos que intervienen en el problema concreto, y definiremos el estado inicial y el estado objetivo.
\end{itemize}

Dada un modelizacion del dominio y una modelizacion del problema, el planificador se encargará de buscarnos un plan válido (si existiera), que contendrá una secuencia de acciones que nos llevarán del estado inicial al estado inicial.

Además, para ciertas extensiones de la práctica, no solo nos interesará buscar un plan válido cualquiera, sino que nos interesará encontrar un plan que optimice un criterio dado (una métrica).

\section{Descripción del problema}
En esta práctica nos encargaremos de planificar un proyecto de programación de gran envergadura.
Deberemos repartir un conjunto de tareas a realizar entre los programadores disponibles.

En concreto, disponemos de $T$ tareas de programación, cada una de ellas tiene un grado de dificultad asignado (de 1 a 3), y un tiempo estimado de realización estimado (en horas).

También disponemos de un conjunto $P$ de programadores. Cada uno de ellos tiene asignado un grado de habilidad (de 1 a 3), que nos indica lo mucho o poco que éste está capacitado para resolver las tareas.

No queremos asignar a los programadores tareas mucho más difíciles de lo que para ellos están capacitados. En concreto, a un programador solo le podremos asignar tareas de como mucho una unidad más de dificultad de lo que nos indique su habilidad. En caso de que sea necesario asignar a un programador una tarea más difícil que su capacidad, la duración de la realización de la tarea se verá incrementada en 2 horas.

Además, todas las tareas deberán ser revisadas, para ello, hará falta una nueva tarea adicional. Esta nueva tarea de revisión será de la misma dificultad que la tarea original.
Los programadores tienen también asociada una calidad (de 1 a 2). Si la tarea original es realizada por un programador de calidad 1, la nueva tarea de revisión durará 1 hora, si en cambio el programador era de calidad 2, la nueva tarea de revisión durará 2 horas. 
Para evitar una recursividad infinita, las nuevas tareas de revisión no requerirán a su vez de revisión, y su tiempo de realización no se verá penalizado por la habilidad del programador que la realiza.


\section{Nivel básico} \label{basic}
En esta primera versión problema, solamente tendremos como objetivo que todas las tareas queden asignadas a algún programador, sin tener en cuenta las tareas de revisión asociadas, y sin intentar optimizar ningún criterio.

\subsection{Dominio}
\subsubsection{Variables}
Para la correcta resolución de este problema de planificación hemos visto conveniente trabajar con variables con tipo.
En concreto, hemos necesitado 2 tipos, los cuáles hemos llamado \textbf{programador} y \textbf{tarea}.

\begin{itemize}
  \item \textbf{programador:} Se utilizará para las variables que correspondan a cada programador del conjunto $P$.
  \item \textbf{tarea:} Se utilizará para las variables que correspondan a cada tarea del conjunto $T$.
\end{itemize}

Para las próximas extensiones ya no se requieren más cambios en las variables, esta será la configuración definitiva.

\subsubsection{Funciones}
\begin{itemize}
  \item \textbf{habilidadProgramador:} Esta función nos servirá para definir y conocer la habilidad de un programador determinado. La habilidad de un programador se representa con un número entero 1, 2 o 3.
  \item \textbf{dificultadTarea:} Esta función nos servirá para definir y conocer la dificultad de una tarea determinada. La dificultad de una tarea se representa con un número entero 1, 2 o 3.
\end{itemize}
\subsubsection{Predicados} \label{basic_predicado}
\begin{itemize}
  \item \verb|(asignacion ?x - programador ?y - tarea)|
  
  Al programador \texttt{x} se le ha sido asignada la tarea \texttt{y}, por lo tanto, éste deberá ser el encargado de realizarla.
  
  \item \verb|(tareaAsignada ?x - tarea)|
  
  Nos indica que la tarea \texttt{x} ha sido asignada a algún programador. Nos servirá para evitar asignar dos veces la misma tarea.
\end{itemize}
\subsubsection{Acciones} \label{basic_accion}
\begin{itemize}
  \item \textbf{asignar:} Esta acción nos sirve para asignar una tarea a un programador.
  
  \textbf{Parámetros}
  \begin{itemize}
  	\item \verb|?p - programador|
  	\item \verb|?t - tarea|
  \end{itemize}
  
  \textbf{Precondición}
  \begin{itemize}
  	\item La tarea \texttt{t} no está asignada.
  	\item La habilidad del programador \texttt{p} debe ser más grande o igual que la dificultad de la tarea \texttt{p} más uno.
  \end{itemize}
  
   \textbf{Postcondición}
   \begin{itemize}
  	\item La tarea \texttt{t} ha sido asignada al programador \texttt{p}.
  \end{itemize}
  
\end{itemize}

\subsection{Problema}
\subsubsection{Objetos}
Para la modelización del problema tenemos que definir el conjunto de tareas y el conjunto de programadores de los que disponemos, declarando tantas variables (objetos) como requiramos.

\subsubsection{Estado inicial} \label{basic_estadoinicial}
Para cada tarea:
\begin{itemize}
  	\item Definimos la dificultad de la tarea (1, 2 o 3).
\end{itemize}

\noindent
Y para cada programador:
\begin{itemize}
  	\item Definimos la habilidad del programador (1, 2 o 3).
\end{itemize}

\subsubsection{Estado final}
Para el estado final, requerimos que todas las tareas estén asignadas:

\begin{verbatim}
(:goal (forall (?t - tarea) (tareaAsignada ?t))))
\end{verbatim}

\subsection{Juegos de prueba}


\section{Extensión 1}

En esta extensión, vamos a añadir a nuestro programa la revisión de tareas.
La revisión de tareas consiste en que cada vez que algún programador realice una tarea, esta deberá ser revisada por otro programador. La dificultad de la revisión será la misma que de la tarea y por lo tanto utilizaremos el mismo criterio para asignar un programador, para revisar que en la sección \ref{basic}.

\subsection{Dominio}
\subsubsection{Funciones}

Para esta extensión vamos a utilizar las mismas funciones que en el apartado anterior.

\subsubsection{Predicados}

\begin{itemize}
  \item \verb|(asignacionTarea ?x - programador ?y - tarea)|
  
  Equivalente al predicado "asignacion" en la sección \ref{basic_predicado}.
  
  
  \item \verb|(asignacionRevision ?x - programador ?y - tarea)|
  
  Predicado utilizado para asignar a una tarea un programador para que este la revise. 
  
  
  \item \verb|(tareaAsignada ?x - tarea)|
  
  Igual que en la sección \ref{basic_predicado}.
  
  
  \item \verb|(tareaRevisada ?x - tarea)|
  
  Predicado para conocer si la tarea en questión ha sido revisada por algún programador.
  
\end{itemize}

\subsubsection{Acciones}

\begin{itemize}
  \item \textbf{asignar:}
  Esta acción és equivalente a la acción ``asignar" explicada en la sección \ref{basic_accion}. Donde el único cambio es el cambio de nombre del predicado de ``asignacion" a "asignacionTarea".
  \item \textbf{revisar:} El objetivo de esta acción es a partir de las tareas ya asignadas, asignar una revisión a todas la tareas con un programador diferente del que ha tenido asignada la tarea, el cual debe tener habilidad suficientemente grande para poder revisarla.
  
  \textbf{Parámetros}
  \begin{itemize}
  	\item \verb|?p - programador|
  	\item \verb|?t - tarea|
  \end{itemize}
  
  \textbf{Precondición}
  
  Para poder realizar esta acción se debe cumplir:
  \begin{itemize}
  	\item La tarea \texttt{t} esta asignada.
  	\item La tarea \texttt{t} no esta revisada
  	\item La habilidad del programador \texttt{p} debe ser más grande o igual que la dificultad de la tarea \texttt{t} más uno.
  	\item El programador \texttt{p} no puede ser el programador que ha realizado la tarea \texttt{t}.
  \end{itemize}
%\begin{verbatim}
 % (and (tareaAsignada ?t) (not (tareaRevisada ?t)) (>= (habilidadProgramador ?p) (- (dificultadTarea ?t) 1)) (not (asignacionTarea ?p ?t)))
 % \end{verbatim}
 
  \textbf{Postcondición}
  
  \begin{itemize}
  	\item La tarea \texttt{t} ha sido revisada por el programador \texttt{p}.
  	\item La tarea \texttt{t} está revisada.
  \end{itemize}
%\begin{verbatim}
 % (and (asignacionRevision ?p ?t) (tareaRevisada ?t))
 % \end{verbatim}
\end{itemize}

\subsection{Problema}
\subsubsection{Estado inicial}

Para cada tarea:
\begin{itemize}
  	\item Definimos la dificultad de la tarea (1, 2 o 3).
\end{itemize}

\noindent
Y para cada programador:
\begin{itemize}
  	\item Definimos la habilidad del programador (1, 2 o 3).
\end{itemize}

\subsubsection{Estado final}

El estado final remplazaremos la comprobación de de que todas las tareas estén asignadas, por la comprobación de que todas las tareas estén revisadas.
\begin{verbatim}
(forall (?t - tarea) (tareaRevisada ?t))
\end{verbatim}
\subsection{Juegos de prueba}

\section{Extensión 2}
En la siguiente extensión, partiendo de la anterior, tenemos como objetivo minimizar el tiempo total que se usa en resolver todas las tareas. El tiempo total se interpreta como la suma de las horas de las tareas, tanto las principales como las de revisión. 
\\
En este caso, minimizar significa otorgar las tareas dependiendo de la habilidad o calidad del programador para que las tareas o sus respectivas revisiones sean menos duraderas. 
\subsection{Dominio}
\subsubsection{Funciones}

Puesto a que esta es la primera extensión donde observamos el concepto de tiempo, hemos tenido que añadir funciones además de las mencionadas anteriormente. 
\begin{itemize}

\item \textbf{tiempoTarea}: Esta función nos servirá para definir y conocer el tiempo asociado a una tarea \textit{T}.
\item \textbf{tiempoTotal}: Esta función nos servirá para definir y conocer la suma de duración de todas las tareas. Es decir el tiempo total que representa el conjunto de tareas. 

\end{itemize}
\subsubsection{Predicados}
En cuanto a lo que concierne a los predicados, utilizamos los mismos que en la extensión anterior.
\subsubsection{Acciones}
Además de las acciones utilizadas anteriormente hemos tenido que añadir \textbf{asignarDificil} y modificar \textbf{asignar} y \textbf{revisar} para añadir los conceptos de tiempo en nuestro sistema.
\begin{itemize}
	\item \textbf{asignar}: Esta acción nos sirve para asignar una tarea a un programador que tiene un valor de habilidad = dificultadTarea -1. 
	\textbf{Parámetros}
	\begin{itemize}
		\item ?p - programador
		\item ?t - tarea
	\end{itemize}
	\textbf{Precondición}
	\begin{itemize}
		\item La tarea t no está asignada
		\item La habilidad del programador p es igual que la dificultad de la tarea p menos uno. 
	\end{itemize}
	\textbf{Postcondición}
	\begin{itemize}	
		\item La tarea t ha sido asignada al programador p.
		\item Se ha incrementado el tiempo total el tiempo que tarda en realizarse la tarea con una penalización de 2 horas denido a su habilidad.
	\end{itemize}

	\item \textbf{asignarDificil}: Esta acción es idéntica que la anterior pero con la diferencia de que esta sirve para asignar tareas a los programadores que tienen una habilidad mayor o igual a la dificultad de la tarea. En este caso se incrementa el Tiempo total con el tiempo de la tarea sin penalización alguna.

	\item \textbf{revisar}: Esta acción nos sirve para asignar una tarea de revisión a un programador. 
	\textbf{Parámetros}
	\begin{itemize}
		\item ?p - programador
		\item ?t - tarea
	\end{itemize}
	\textbf{Precondición}
	\begin{itemize}
		\item La tarea t no está asignada
		\item La tarea no debe estar revisada
		\item La habilidad del programador p debe ser más grande o igual que la dificultad de la tarea p más uno.
		\item El programador que revisa la tarea no puede ser el mismo que el que la ha realizado. 
	\end{itemize}
	\textbf{Postcondición}
	\begin{itemize}	
		\item Se ha asignado a un programador la tarea de revisión.
		\item La tarea está revisada. 
		\item Se ha incrementado el tiempo total el tiempo que tarda en revisarse la tarea, el cual depende de la calidad del programador.
	\end{itemize}
	
\end{itemize}

\subsection{Problema}
\subsubsection{Estado inicial}
\noindent
Para cada programador:
\begin{itemize}
  	\item Definimos la habilidad del programador (1, 2 o 3).
  	\item Definimos la calidad del programador (1 o 2).
\end{itemize}

Para cada tarea:
\begin{itemize}
  	\item Definimos cuanto tiempo tarda en hacerse.
  	\item Definimos la dificultad de la tarea (1, 2 o 3).
\end{itemize}
Además inicializamos el valor de \textit{tiempoTotal}. 

\subsubsection{Estado final}
Para el estado final, de la misma manera que en la anterior extensión, requerimos que todas las tareas esten revisadas. No obstante, en este caso añadimos una métrica: \textbf{minimizar el valor de tiempoTotal}.
\begin{verbatim}
(:goal (forall (?t - tarea) (tareaRevisada ? t))) 
(:metric minimize (tiempoTotal))
\end{verbatim}

\subsection{Juegos de prueba}
\subsubsection{Prueba que minimice según la habilidad del programador} 
\underline{\textbf{Input}}\\

En este caso introduciremos un juego de prueba que muestre como nuestro sistema es capaz de minimizar el tiempo con las asignaciones realizadas según la habilidad del programador. 
\begin{verbatim}

\end{verbatim}

\noindent \underline{\textbf{Output}}\\

\begin{verbatim}

\end{verbatim}
\noindent \underline{{\textbf{Justificación}}}\\
En este caso podemos ver como se ha cumplido el objetivo de la extensión que era que se minimizara el tiempoTotal. Además podemos observar que en este caso se ha minimizado según la habilidad del programador. 

\subsubsection{Prueba que optimize según la calidad del programador} 
\underline{\textbf{Input}}\\
En este caso introduciremos un juego de prueba que muestre como nuestro sistema es capaz de minimizarel tiempo con las asignaciones realizadas según la calidad del programador. 
\medskip

\noindent \underline{\textbf{Output}}\\


\medskip


\noindent \underline{\textbf{Justificación}}\\
En este caso podemos ver como se ha cumplido el objetivo de la extensión que era que se minimizara el tiempoTotal. Además podemos observar que en este caso se ha minimizado según la calidad del programador. 

\section{Extensión 3}
En la siguiente extensión, partiendo de la anterior, tenemos como objetivo limitar el número de tareas que podemos asignar a una persona a 2. Por consiguiente, aumentaremos el número de personas trabajando en paralelo. 
\subsection{Dominio}
\subsubsection{Funciones}
En esta extensión tenemos que limitar el número de tareas por programador, de manera que necesitamos algun método para mantener la consistencia. En nuestro caso hemos decidido crear una función.
\begin{itemize}
	\item \textbf{nTareasProgramador}:Esta función nos servirá para definir y conocer el número de tareas que esta realizando un programor p.  
\end{itemize}
\subsubsection{Predicados}
Para esta extensión vamos a utilizar los mismos predicados que la anterior extensión.
\subsubsection{Acciones}
Para esta extensión vamos a utilizar las mismas acciones que en la anterior extensión.
\subsection{Problema}
\subsubsection{Estado inicial}
Para cada programador:
\begin{itemize}
  	\item Definimos la habilidad del programador (1, 2 o 3).
  	\item Definimos la calidad del programador (1 o 2).
\end{itemize}

\noindent Para cada tarea:
\begin{itemize}
  	\item Definimos cuanto tiempo tarda en hacerse.
  	\item Definimos la dificultad de la tarea (1, 2 o 3).
\end{itemize}

\noindent Además inicializamos los valores de \textit{tiempoTotal} y el número de tareas de cada programador, \textit{nTareasProgramador}. 

\subsubsection{Estado final}
Para el estado final, de la misma manera que en la anterior extensión, requerimos que todas las tareas esten revisadas y además que se minimice el tiempo total. Además, añadimos también la restricción de que cada programador solo puede realizar como máximo 2 tareas. 

\begin{verbatim}
(:goal (and (forall (?t - tarea) (tareaRevisada ?t))
	(forall (?p - programador) (<= (nTareasProgramador ?p) 2))))

(:metric minimize (tiempoTotal))
\end{verbatim}
\subsection{Juegos de prueba}
\subsubsection{Prueba estándard}
\underline{\textbf{Input}}\\

En este caso introduciremos un juego de prueba estándard sin ninguna complicación para comprovar que se realiza correctamente el objetivo de la extensión. 
\begin{verbatim}
(define (problem test-01) (:domain task) 
	(:objects p0 p1 p2 - programador
t0 t1 - tarea)
	(:init
	(=  (habilidadProgramador p0) 3)
	(=  (calidadProgramador p0) 2)
	(=  (nTareasProgramador p0) 0)

	(=  (habilidadProgramador p1) 1)
	(=  (calidadProgramador p1) 2)
	(=  (nTareasProgramador p1) 0)

	(=  (habilidadProgramador p2) 3)
	(=  (calidadProgramador p2) 2)
	(=  (nTareasProgramador p2) 0)

	(=  (dificultadTarea t0)1)
	(=  (tiempoTarea t0)4)

	(=  (dificultadTarea t1)3)
	(=  (tiempoTarea t1)6)

	(= (tiempoTotal) 0 )
)
(:goal (and (forall (?t - tarea) (tareaRevisada ?t))
 (forall (?p - programador) (<= (nTareasProgramador ?p) 2))))
 (:metric minimize (tiempoTotal))
 )
 \end{verbatim}
 \medskip

 \noindent \underline{\textbf{Output}}
\medskip
\begin{verbatim}
ff: found legal plan as follows
step    0: ASIGNAR P0 T1
        1: REVISAR P2 P0 T1
        2: ASIGNAR P1 T0
        3: REVISAR P2 P1 T0
plan cost: 14.000000

\end{verbatim}
\medskip

\noindent \underline{\textbf{Justifación}}\\

En este caso podemos ver como se ha cumplido el objetivo de la extensión que era que cada programador tuviera como máximo 2 tareas. 

\subsubsection{Prueba imposible de realizar}
\noindent \underline{\textbf{Input}} \\

En este caso hemos creado un juego de prueba que resulte imposible de realizar ya que cada persona tendría que realizar más de 2 tareas. 
\medskip
\begin{verbatim}
(define (problem test-01) (:domain task) 
	(:objects p0 p1 p2 - programador
t0 t1 t2 t3 t4 - tarea)
	(:init
	(=  (habilidadProgramador p0) 2)
	(=  (calidadProgramador p0) 1)
	(=  (nTareasProgramador p0) 0)

	(=  (habilidadProgramador p1) 1)
	(=  (calidadProgramador p1) 1)
	(=  (nTareasProgramador p1) 0)

	(=  (habilidadProgramador p2) 1)
	(=  (calidadProgramador p2) 2)
	(=  (nTareasProgramador p2) 0)

	(=  (dificultadTarea t0)2)
	(=  (tiempoTarea t0)1)

	(=  (dificultadTarea t1)1)
	(=  (tiempoTarea t1)4)

	(=  (dificultadTarea t2)1)
	(=  (tiempoTarea t2)1)

	(=  (dificultadTarea t3)3)
	(=  (tiempoTarea t3)5)

	(=  (dificultadTarea t4)1)
	(=  (tiempoTarea t4)6)

	(= (tiempoTotal) 0 )
)
(:goal (and (forall (?t - tarea) (tareaRevisada ?t))
 (forall (?p - programador) (<= (nTareasProgramador ?p) 2))))
 (:metric minimize (tiempoTotal))
 )

\end{verbatim}

\noindent \underline{\textbf{Output}}

\begin{verbatim}
Astar epsilon search space empty!
Bailing out.
\end{verbatim}
\noindent \underline{\textbf{Justificación}}

Tal y como esperábamos, al tener tantas tareas (8 si contamos su realización y su revisión pertinente) y tan pocos programadores (3) era imposible obtener una solución. 
\medskip

\section{Extensión 4}

En esta última extensión, partiendo de la anterior, tenemos como objetivo minimizar, además del número de horas, el número de programadores. 
\subsection{Dominio}
\subsubsection{Funciones}
En esta extensión tenemos que conocer el número de trabajadores que tienen alguna tarea asignada por tal de poder minimizar este número. Para tener esta informacion hemos creado una función.
\begin{itemize}
	\item \textbf{programadoresTotal}:Esta función nos servirá para contar el número total de programadores que tienen asignada alguna tares.  
\end{itemize}
\subsubsection{Predicados}
Para esta extenison hemos añadido un nuevo predicado que nos permite conocer si ya hemos contabilizado al programador para el contador programadoresTotal.
\begin{itemize}
  \item \verb|(programadorContado ?x - programador)|
  
  El programador \texttt{x} ha sido contado para la función programadoresTotal.
\end{itemize}
\subsubsection{Acciones}
Además de las acciones utilizadas anteriormente hemos tenido que añadir \textbf{contar} y \textbf{nocontar}.
\begin{itemize}
	\item \textbf{contar}: Esta acción nos sirve para incrementar la función programadoresTotal cuando un programador tiene alguna tarea o revisión asignada. 
	\textbf{Parámetros}
	\begin{itemize}
		\item ?p - programador
	\end{itemize}
	\textbf{Precondición}
	\begin{itemize}
		\item El programador \texttt{p} no ha sido contado.
		\item Todas las tareas han sido revisadas.
		\item El número de tareas del programador \texttt{p} és mayor a 0. 
	\end{itemize}
	\textbf{Postcondición}
	\begin{itemize}	
		\item El programador \texttt{p} ha sido contado.
		\item Se ha incrementado en 1 el contador programadoresTotal en uno.
	\end{itemize}

	\item \textbf{nocontar}: Esta acción nos sirve para no contar a los programadores sin tareas. 
	\textbf{Parámetros}
	\begin{itemize}
		\item ?p - programador
	\end{itemize}
	\textbf{Precondición}
	\begin{itemize}
		\item El programador \texttt{p} no ha sido contado.
		\item Todas las tareas han sido revisadas.
		\item El número de tareas del programador \texttt{p} és igual a 0. 
	\end{itemize}
	\textbf{Postcondición}
	\begin{itemize}	
		\item El programador \texttt{p} ha sido contado.
	\end{itemize}
	
\end{itemize}
\subsection{Problema}
\subsubsection{Estado inicial}
Para cada programador:
\begin{itemize}
  	\item Definimos la habilidad del programador (1, 2 o 3).
  	\item Definimos la calidad del programador (1 o 2).
\end{itemize}

\noindent Para cada tarea:
\begin{itemize}
  	\item Definimos cuanto tiempo tarda en hacerse.
  	\item Definimos la dificultad de la tarea (1, 2 o 3).
\end{itemize}

\noindent Además inicializamos los valores de \textit{tiempoTotal}, \textit{programadoresTotal} y el número de tareas de cada programador. 

\subsubsection{Estado final}
En este caso cómo todas las tareas deben estar inicializadas para poder contar el número de programadores con tareas el estado final se cumplirà cuando se haya contado a todos los programadores y cuando todos los programadores realizen menos de 2 tareas.
En esta ocasion minimizaremos el tiempo total y el número de programadores.

\begin{verbatim}
(:goal (forall (?p - programador) (and (<= (nTareasProgramador ?p) 2)
					(programadorContado ?p))))
    
(:metric minimize (+ (tiempoTotal) (programadoresTotal)))
\end{verbatim}
\subsection{Juegos de prueba}


\section{Conclusiones}


\newpage
\appendix
\appendixpage
\addappheadtotoc

\section{Generador de juegos de prueba}

Generar a mano varios casos de prueba es una tarea ardua y monótona que puede ser fácilmente automatizable, así pues, para poder probar varios valores rápidamente, decidimos crear un generador de juegos de prueba. En nuestro caso hemos decidido utilizar el lenguaje de scripting \textbf{Python} para generar casos de prueba automáticamente.
\medskip

Nuestro generador de pruebas admite tres parámetros distintos:
\begin{itemize}
	\item \textit{--programadores P}, donde P es el número de programadores que queremos
	\item \textit{--tareas T}, donde T es el número de programadores que queremos
	\item \textit{--extension E} donde E es la extensión que deseamos utilizar. 
\end{itemize}
\medskip
\noindent Finalmente se genera un documento llamado \textit{fichero\_generadoN.pddl} donde la N es la extensión que hemos seleccionado en los argumentos del programa. 

\end{document}
